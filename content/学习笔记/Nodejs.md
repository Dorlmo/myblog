---
title: Nodejs
index: 13
publishTime: 2023/9/9
---

Q:CJS和ESM的区别

A:CJS（CommonJS）和ESM（ECMAScript Modules）都是JavaScript模块系统，用于在JavaScript应用程序中组织和管理代码。它们有一些重要的区别：

1. **加载时间**：
   - **CJS**：CommonJS是一种同步加载模块的系统，模块在需要时立即加载，它们会阻塞代码的执行，直到模块加载完成。
   - **ESM**：ECMAScript Modules是一种异步加载模块的系统，模块在需要时会异步加载，不会阻塞代码的执行。
2. **语法**：
   - **CJS**：CommonJS使用`require`来导入模块，使用`module.exports`或`exports`来导出模块。
   - **ESM**：ECMAScript Modules使用`import`来导入模块，使用`export`来导出模块。
3. **静态分析**：
   - **CJS**：由于CommonJS是同步加载的，模块的依赖关系在运行时确定，这使得静态分析和优化较困难。
   - **ESM**：ECMAScript Modules是异步加载的，模块的依赖关系在代码解析阶段就已经确定，使得静态分析和优化更容易实现。
4. **顶级作用域**：
   - **CJS**：每个CommonJS模块都有自己的顶级作用域，模块内部的变量不会泄漏到全局作用域。
   - **ESM**：ECMAScript Modules默认不会创建自己的顶级作用域，模块内部的变量不会自动成为全局变量，需要显式导出才能在其他模块中使用。
5. **浏览器支持**：
   - **CJS**：CommonJS最初是为服务器端开发而设计的，不是浏览器原生支持的模块系统，需要使用工具（如Browserify或Webpack）来在浏览器中使用。
   - **ESM**：ECMAScript Modules是ECMAScript标准的一部分，现代浏览器原生支持，不需要额外的工具。
6. **动态导入**：
   - **CJS**：CommonJS不支持动态导入，无法在运行时根据条件加载模块。
   - **ESM**：ECMAScript Modules支持动态导入，可以根据需要在运行时加载模块。

总的来说，CJS主要用于服务器端开发和早期的Node.js应用程序，而ESM则是现代JavaScript的标准模块系统，适用于浏览器和Node.js。选择哪种模块系统取决于你的项目需求和环境。在现代项目中，通常更推荐使用ESM，因为它具有更好的性能和更广泛的支持。



Q:Nodejs EventLoop

A:Node.js 是一种流行的运行时环境，用于在服务器端执行 JavaScript 代码。  其主要功能之一是事件驱动的非阻塞 I/O 模型，该模型由事件循环提供支持。  了解 Node.js 事件循环对于编写高效且可扩展的应用程序至关重要。 

以下是 Node.js 事件循环工作原理的概述： 

1. **事件循环基础知识** ： 
   - Node.js 的核心是使用事件循环来有效地处理异步操作。 
   - 事件循环是一个单线程结构，以非阻塞方式管理所有 I/O 操作和回调。 
   - 它使 Node.js 能够处理大量并发连接，而无需为每个连接创建线程。 
2. **事件循环的阶段** ： 
   - Node.js 事件循环由几个阶段组成： 
     - **Timers(计时器)** ：此阶段负责执行使用计划的回调 `setTimeout()`和 `setInterval()`. 
     - **I/O Callbacks(I/O 回调)** ：来自 I/O 操作的回调，例如文件系统操作或网络请求，在此阶段处理。 
     - **Idle, Prepare(空闲、准备)** ：这些阶段很少使用，但可用于特殊情况。 
     - **Poll(轮询)** ：这是事件循环的核心。   它不断检查 I/O 事件并处理它们，并且在没有事件时阻塞。 
     - **Check(检查)** ：注册的回调 `setImmediate()`都在这个阶段执行。 
     - **Close Callbacks(关闭回调)** ：处理关闭事件，例如 `socket.on('close', ...)`. 
3. **执行顺序** ： 
   - 事件循环按照预定义的顺序重复经历这些阶段。 
   - 它从“定时器”阶段开始，进入“I/O 回调”阶段，然后是“轮询”阶段，依此类推。 
   - 每个阶段都按照 FIFO（先进先出）顺序执行任何挂起的回调。 
4. **回调** ： 
   - 当异步操作完成时（例如，读取文件或发出 HTTP 请求），相应的回调函数将添加到事件循环中。 
   - 回调在各自的阶段处于活动状态时执行，并且事件循环会迭代这些阶段。 
5. **并发和非阻塞** ： 
   - Node.js 是单线程的，但它通过非阻塞操作实现并发。  当一项操作正在等待 I/O 时，事件循环可以处理其他操作。 
6. **事件发射器** ： 
   - 许多 Node.js 模块和类都是围绕 EventEmitter 模式构建的。  对象可以发出事件，并且您可以附加侦听器（回调）来处理这些事件。 
7. **错误处理** ： 
   - 正确的错误处理至关重要，因为未处理的错误可能会使 Node.js 进程崩溃。 
   - 您可以使用 `try...catch`并提供错误回调以优雅地处理错误。 
8. **SetImmediate 与 setTimeout**  ： 
   - `setImmediate()`和 `setTimeout()`通常用于安排代码执行，但是 `setImmediate()`回调在事件循环的“检查”阶段执行，通常早于 `setTimeout()`. 

总之，Node.js 事件循环是一个关键组件，它支持非阻塞、异步 I/O 操作，使其适合构建可扩展且高效的服务器应用程序。  了解事件循环的运行方式对于编写在负载下表现良好并有效处理并发的 Node.js 代码至关重要。 



Q:pnpm的原理

A://pnpm是一个类似npm的包管理工具，各种功能使用基本相同

pnpm的原理基于一些关键概念和技术，使其能够快速、高效地管理Node.js项目的依赖。以下是pnpm的主要原理：

1. **符号链接（Symbolic Links）：** pnpm使用符号链接（也称为软链接）来创建依赖之间的关联。这意味着如果多个项目都依赖于相同的包，它们可以共享同一个实际的包副本，而不是在每个项目中都复制一份。这极大地减少了磁盘空间的占用，因为相同的包只存储一次。
2. **硬链接（Hard Links）：** pnpm还使用硬链接来将包的不同版本之间建立联系。当你升级或切换包的版本时，只有修改的文件会被复制，而其他文件则通过硬链接与旧版本共享。这进一步减少了磁盘空间的使用。
3. **版本管理和锁文件：** pnpm支持类似于npm和Yarn的版本管理，它会生成一个`pnpm-lock.yaml`文件来记录依赖的确切版本。这确保了在不同环境中复现项目时使用相同的依赖版本。
4. **全局存储库：** pnpm维护一个全局存储库，用于存储项目之间共享的包。这个存储库位于用户的文件系统中，通常是`~/.pnpm-store`目录。全局存储库中的包可以被多个项目引用，而不必在每个项目中单独存储。
5. **并行安装：** pnpm允许并行安装依赖，这意味着它可以同时处理多个包的安装，从而显著提高了安装速度。
6. **包的只读性：** 为了确保包的安全性，pnpm保持了依赖包的只读性，防止它们在项目中被意外修改。

总的来说，pnpm的核心原理是通过符号链接、硬链接以及全局存储库等技术来减少磁盘占用、提高安装速度，并实现依赖版本管理。这些原理共同作用，使pnpm成为一个高效的Node.js包管理工具。
