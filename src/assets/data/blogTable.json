[{"tableName":"学习笔记","blogList":[{"name":"说明","path":"学习笔记/说明.html","texts":"关键字和一图流文档用来提醒\n\nchatGPT专辑则是解释理解作用\n\n其他的是看了资料后尝试用口语模拟面试回答问题","frontMatter":{"title":"说明","index":1,"publishTime":"2023/7/25"}},{"name":"关键字","path":"学习笔记/关键字.html","texts":"记录了一些关键字，方便联想\n\n\n网络协议\n\nhttp，https，tcp，udp，websocket\n\n\n网络\n\n原理，请求方式，请求头，响应头，http2.0，http状态码，cookie，sessionStorage，localStorage，keepAlive，跨域\n\n\n编程\n\n简单说明各种语言的区别(C++，java，Python，go，Rust，JavaScript)\n\n\n前端\n\n图片的懒加载和预加载，模块化（CJS，AMD，CMD，ES6），浏览器渲染页面的过程，渲染进程，重绘重排，按需加载，virtual DOM，Dom，DOM\napi，BOM，window，navigator，screen，location，history，setTimeout()，setInterval()，document.cookie，移动端适配，性能优化，移动端兼容性，小程序开发，移动端300ms延迟问题，，XSS攻击\n\n\nHTML\n\n语义化标签，iframe，doctype，块元素和行元素\n\n\nCSS\n\ntransition，animation，flex布局，BFC，元素垂直居中，文本对齐，选择器，元素消失的方式，溢出处理，calc()，position，z-index，bg-color，inline-block，inline，block，像素单位（px，em，rem，%，vw，vh，vmin）\n\n\nJAVASCRIPT\n\n闭包，类（继承，创建），各种继承类型（原型链继承，构造函数继承，实例继承，拷贝继承，组合继承，寄生组合继承），回调地狱，Generator，事件流（捕获，目标，冒泡），new，bind，apply，call，JS拖拽功能，垃圾回收，引用计数，标记清除，eval，深度克隆，监听对象的属性，==和===和Object.is的区别，setTimeout和setInterval和requestAnimationFrame的区别，实现bind函数，使用setTimeout实现setInterval，实现sleep效果，实现promise，Object.getPrototypeOf()，对部分对象的深度克隆（包装的对象，Date，正则对象），箭头函数中的this指向，判断类型的方法，数组的方法，字符串去除首尾空格，数值比较规则，null==undefined，this的指向，原型链，string的startWith和indexof的区别，字符串转数字，let、const、var，箭头函数，事件模型，如何获取对象属性，ES6新特性，private和public实现，Event\nLoop\n\n\nGIT\n\n工作流，rebase，merge，git reset和git revert和git checkout的区别\n\n\n框架\n\nwebpack，gulp，前两个的区别，axios，react，vue-router\n\n\nVUE\n\n介绍，Vue和react、Angularjs、Jquery的不同，虚拟DOM，Vue3生命周期，监听事件监听对象变化，delete和Vue.delete，watch和computed，双向数据绑定原理，v-model，为什么Vue要用Proxy\nAPI代替defineProperty，Vue3做了什么优化，Composition\nAPI，Vue的优化（底层，源码），hoistStatic静态提升，cacheHandlers，权限管理的实现，watchEffect和watch","frontMatter":{"title":"关键字","index":2,"publishTime":"2023/7/25"}},{"name":"一图流","path":"学习笔记/一图流.html","texts":"","frontMatter":{"title":"一图流","index":3,"publishTime":"2023/7/25"}},{"name":"网络协议","path":"学习笔记/网络协议.html","texts":"1.http：一种网络协议，是用于在网络传输数据的协议，他是无状态的协议。（服务器不会记住之前与客户端的连接状态，每次请求都是独立的），采用明文传输，端口80。\n\nhttps：在http的基础上，在数据传输中采用了各种方式进行加密保证数据安全。采用密文传输，端口443.\n\n2.https的工作原理：\n\n客户端会先发送一个请求进行连接。服务端收到请求后会返回数字证书给客户端，数字证书用于验证服务端的合法性，内部也储存了服务端的公钥，一旦验证成功，服务端将生成一个对称密钥并使用服务端的公钥进行加密然后发送给服务端，服务端收到后用私钥进行解密获得对称密钥，接下来的数据运输将使用这个对称密钥进行加密解密。\n\n3.http和https的优劣：\n\nHTTP：好：1.简单易用2.速度快 坏：1.没有安全加密 2.不能确保数据完整 HTTPS：好1.数据加密2.数据完整3.身份验证\n坏：1.额外的计算资源开销2.数字证书的购买和刷新\n\n4.tcp三次握手：\n\n第一次：客户端向服务端发送一个特殊的报文，其序列号采用了随机初始化的序列号且syn的标志位为1，发送后客户端的状态变为SYN_SENT。\n\n第二次：服务端在收到这个报文后，发送一个响应报文，其中syn和ack的标志位设置为1，并且初始化一个序列号作为报文的序列号，将收到报文的序列号+1作为响应报文的确认号。服务端进入SYN-RECEIVED状态。\n\n第三次：客户端收到了服务端的报文后，发送响应报文，其中ack的标志位设置为1，确认号为服务端的序列号+1，进入ESTABLISHED状态，服务端收到报文后进入ESTABLISHED状态，连接建立。\n\n5.为什么是三次握手：\n\n为什么不是四次握手原因比较简单那就是三次握手都能解决连接了就不需要多一步画蛇添足，\n\n主要是解释为什么不是二次握手\n\n三次握手第一是为了避免旧连接问题，如果是二次握手，服务端收到第一个报文后就会进入ESTABLISHED状态进入连接，但是如果此时客户端没有及时收到服务端的报文就会认为连接失败了就会再发一个报文，但是对于服务端来说连接已经建立了，这样就会造成困惑的情况。如果是三次握手，服务端必须收到确认报文才会进入ESTABLISHED状态，否则变回等待状态，这样就不会出现上述问题\n\n第二个是客户端不能确认服务端的序列号，在两次握手中，服务端向客户端发送的响应报文只有确认号，序列号并不包含服务端的序列号\n\n//前面两个报文丢失了比较简单大概就是超时重传超时关闭\n\n6.如果第三个报文传送失败了会怎么样？\n\n客户端发送的确认报文如果丢失并不会重传，此时服务端并没有收到确认报文因此会向客户端再次发送第二次握手的报文，如果始终没有收到确认报文服务端超时自动关闭连接。\n\n7.TCP断开连接的四次挥手\n\n这里假设主动断开连接的是客户端\n\n第一次挥手时，客户端发送FIN报文表示要断开连接，进入FIN_WAIT状态。\n\n第二次，服务端在收到后发送ACK报文表示收到请求，然后进入closed_wait状态，客户端收到ACK后进入FIN_WAIT状态\n\n第三次，等到服务端处理完成数据后发送FIN报文，然后进入LAST_ACK状态\n\n第四次，客户端收到FIN报文后发送ACK报文，然后进入TIME_WAIT状态后等待一段时间关闭，服务端在收到ACK报文后进入CLOSED状态\n\n8.为什么有TIME_WAIT状态？\n\n两个主要原因是确保连接关闭以及处理历史连接。\n\n对于确保连接关闭，服务端在发送FIN报文后需要等待ACK报文，如果超时则会发送新的FIN报文，如果客户端收到FIN报文后发送ACK报文然后关闭，如果这个ACK报文丢失，超时重传的FIN到达也无法让客户端发送新的ACK报文，这样就无法优雅断开连接。\n\n其次是处理历史连接，有一部分数据报文可能无法即时到达，如果此时关闭连接且TIME_WAIT状态时间过短，然后断开后马上建立新连接，此时旧数据报到达，设备会正常接受数据，这样会造成序列号紊乱。\n\n9.介绍一下TCP\n\nTCP是一种面向连接的传输层协议，他要求双方传输数据前需要事先建立一个连接。与此同时，TCP通过确认和数据重传机制保证可靠连接，TCP使用滑动窗口机制，保证数据的连续性而且限制了发送的数据数量。而且还具有拥塞控制\n\n10.介绍一下UDP\n\n（基本都是说UDP没有TCP的什么什么）\n\n11.UDP与TCP的不同？\n\nTCP连接，UDP不连接；TCP可靠，UDP不可靠；TCP不快，UDP快\n\n12.TCP与UDP的应用场合？\n\nTCP：网页连接，邮箱，数据传输\n\nUDP：直播，DNS查询\n\n13.TCP的可靠传输机制？\n\n序列号和确认机制，重传机制，流量控制，拥塞控制\n\n14.TCP的重传机制？\n\n在TCP连接中，服务端会发送带有序列号的数据报，客户端在接收后会向服务端发送确认报文确认已经收到这个数据报，如果服务端超过一段时间没有收到确认，则会重新发送这个数据报\n\n15.TCP的流量控制？\n\nTCP连接中，发送端具有一个滑动窗口，如果已经发送而没有收到确认的数据超过窗口大小则不会继续发送，这样就可以通过窗口大小对发送流量进行控制。\n\n16.TCP的拥塞控制？\n\nTCP连接开始时，会采用慢开始，一开始的发送窗口较小，但每收到一次确认窗口大小翻倍，一直到出现拥塞，就会采用拥塞避免，这时大小增长方式变为线性增长。一旦出现接收到发现数据丢失，发送端就是将窗口大小减半并且进行拥塞避免。如果迟迟收不到确认，窗口大小便会变回1继续慢开始。\n\n17.DNS是什么\n\nDNS就是域名系统（ Domain Name\nSystem），他把一个可读的名字转换为ip地址，这样进入网站就不需要输入ip而是输入“名字”，这样能够大大增强对人的网站访问体验。\n\n18.DNS的完整查询过程\n\n一、本地查询，主机会依次检查浏览器，系统是否拥有域名对应的ip地址\n\n二、如果前面无法完成，那么系统会请求本地域名服务器进行查询\n\n三、如果前面无法完成，那么本地域名服务器、依次对根服务器、顶级域名服务器、权威域名服务器进行递归查询，最后会得到对应的ip地址，缓存起来然后发送给主机。\n\n19.HTTP的请求方式\n\nGET用于从服务器中检索数据，POST用于将将要处理的数据交付给指定的资源，put用于更新数据，DELETE用于删除数据，HEAD和GET类似但是只返回响应头不返回响应体，OPTION用于请求目标资源可用的的通行选项信息（或者不用简单解释直接说也行？）\n\n20.get和post的区别\n\n目的不同，get用于检索数据，post用于交付数据；get数据发送数据明文可见，post不可见；get的请求数据长度较短，post长度长很多；get获取的数据会被缓存，post不会；每一次get的效果应该是相同的，而post不一定\n\n21.介绍HTTP请求方法的OPTION方法及其使用场景\n\n这个方法用于获取目标资源允许的请求方法，还有一些其他信息例如请求头部和认证需求。\n\n一般用于跨域资源共享，进行跨域请求前发送option方法查询是否支持跨域请求\n\n22说几个HTTP的请求头和响应头\n\n请求头：\n\nuser-agent,accept,content-type,referer,connection,cookie,host\n\n响应头：\n\ncontent-type,date,connection,cache-control,server,ser-cookie,expires\n\n23.HTTP304状态码多还是少比较好\n\n基本上都是多比较好，304状态码表示资源未修改，用于get请求中请求的这个资源没有修改所以建议直接读取缓存，这样客户端不用接受数据直接读缓存更快，服务端也不用重发减少负担。","frontMatter":{"title":"网络协议","index":4,"publishTime":"2023/7/25"}},{"name":"网络协议withchatGPT","path":"学习笔记/网络协议withchatGPT.html","texts":"chatGPT主要用于理解方面，对一些问题的子问题进行回答。\n\nQ：我对udp的无连接和http的无状态有一点混淆，怎么解释这两个？（http连接是tcp连接）\n\nA：理解UDP的无连接和HTTP的无状态确实容易混淆，因为它们指的是两个不同的概念。让我为您解释一下它们：\n\n 1. UDP的无连接： UDP（User Datagram\n    Protocol）是一种无连接的传输层协议。这意味着在UDP通信中，通信的两端（发送方和接收方）在交换数据之前不会建立任何连接。UDP不像TCP那样需要进行三次握手来建立连接，也不需要四次握手来终止连接。它简单地将数据分割成数据包（Datagram），并在网络上发送，而无需事先建立连接或维护状态。因为UDP没有建立连接的开销，所以在一些对实时性要求高、但不要求可靠性的场景中使用，例如实时音频、视频传输和在线游戏。\n 2. HTTP的无状态： HTTP（Hypertext Transfer\n    Protocol）是一种应用层协议，用于在Web浏览器和Web服务器之间传输数据。HTTP是无状态的，这意味着每个HTTP请求都是独立的，服务器不会在请求之间保留任何关于客户端状态的信息。在每个HTTP请求中，服务器只处理请求的内容并返回响应，而不会考虑之前的请求历史或会话状态。这使得服务器的设计更加简单，也有助于提高可伸缩性。为了处理用户状态（例如用户登录状态保持），通常使用一些机制，如Cookie和Session，在客户端和服务器之间进行状态管理。\n\n要理解它们之间的区别，可以将UDP的无连接看作是传输层的特性，它处理数据包的发送和接收，而HTTP的无状态是应用层的特性，它处理请求和响应之间的关系和状态。UDP在传输层提供了简单、高效的数据传输，而HTTP在应用层提供了无状态的请求-响应交互，用于在Web应用程序中传输数据。\n\nQ：说明一下https的数据传输加密的工作原理\n\nA：HTTPS（Hypertext Transfer Protocol\nSecure）是一种通过加密来保护数据传输安全的通信协议。它基于HTTP协议，但在其基础上添加了安全层（SSL/TLS），以确保在客户端和服务器之间传输的数据是加密的，从而防止恶意第三方窃听、篡改或伪装数据。下面是HTTPS数据传输加密的工作原理：\n\n 1. 握手阶段（Handshake Phase）:\n    当客户端（通常是Web浏览器）与服务器建立HTTPS连接时，首先会发生一系列握手过程，主要涉及SSL/TLS协议。握手阶段的目标是确保双方之间建立安全的通信渠道并协商加密算法和密钥。\n 2. 客户端发送请求: 客户端向服务器发送一个连接请求，请求建立一个安全的连接。\n 3. 服务器证书验证：\n    服务器在收到客户端请求后，会向客户端返回其公开的数字证书。数字证书中包含了服务器的公钥，以及一些元数据信息，比如证书的颁发机构、有效期等。客户端会验证证书的有效性，确保证书是由受信任的证书颁发机构（CA，Certificate\n    Authority）签署的，且证书没有过期或被吊销。\n 4. 客户端生成密钥： 如果证书验证通过，客户端会生成一个用于后续数据加密的对称密钥（Session\n    Key），这个密钥只在当前会话中有效，并且只有客户端和服务器知道。\n 5. 服务器公钥加密： 客户端使用服务器证书中提供的公钥对生成的对称密钥进行加密，然后将加密后的密钥发送回服务器。\n 6. 服务器解密密钥： 服务器使用其私钥对客户端发送的加密密钥进行解密，获得对称密钥。\n 7. 加密通信：\n    在握手阶段完成后，客户端和服务器都拥有相同的对称密钥，用于加密和解密后续的数据传输。从此刻开始，所有的数据都会使用该对称密钥进行加密，然后在接收端使用同样的密钥进行解密。这样，即使有人在数据传输的过程中截获了加密的数据，由于没有正确的密钥，无法解密其中的内容。\n 8. 数据传输： 在握手阶段完成后，客户端和服务器之间的数据传输是通过使用对称密钥进行加密和解密的，保证数据的安全性和完整性。\n\n总结：HTTPS通过在握手阶段建立安全的通信渠道，使用公钥加密和对称密钥加密相结合的方式，确保数据在传输过程中的保密性和完整性，从而保护用户数据和隐私免受网络攻击和窃听。\n\nQ：什么是对称加密和非对称加密，这里使用的哪种？\n\nA：对称加密和非对称加密是两种常见的加密算法，用于在计算机网络和信息安全领域保护数据的安全性。在HTTPS中，两种加密算法都有用到，但主要的加密工作是通过非对称加密完成。\n\n1.对称加密（Symmetric Encryption）：\n对称加密是一种加密技术，使用相同的密钥（也称为对称密钥）来进行数据的加密和解密。因为加密和解密使用相同的密钥，所以必须确保密钥的安全传输和存储，否则可能会被恶意第三方获取，从而破解加密数据。\n\n在对称加密中，数据发送方使用密钥对数据进行加密，然后将加密后的数据发送给接收方。接收方收到数据后使用相同的密钥进行解密，以恢复原始数据。常见的对称加密算法有AES（Advanced\nEncryption Standard）和DES（Data Encryption Standard）等。\n\n2.非对称加密（Asymmetric Encryption）： 非对称加密是一种加密技术，使用一对密钥，分别是公钥（public key）和私钥（private\nkey）。公钥是公开的，可以被任何人获取，而私钥是私有的，只有密钥的拥有者知道。数据加密和解密使用不同的密钥，即用公钥加密的数据只能用私钥解密，用私钥加密的数据只能用公钥解密。\n\n在非对称加密中，公钥通常用于加密数据，而私钥用于解密数据或签名数据（数字签名）。数据发送方获取接收方的公钥，使用公钥加密数据后发送给接收方。接收方使用私钥解密数据或验证发送方的签名。非对称加密解决了对称加密中密钥分发和安全存储的问题。\n\n在HTTPS中，非对称加密用于建立安全连接，客户端使用服务器的公钥来加密生成的对称密钥，并将其发送给服务器。服务器使用私钥解密客户端发送的对称密钥，从而建立一个安全的通信渠道。之后，数据的传输主要通过对称加密来完成，利用之前建立的安全通道传输加密数据，提供更高效的加密和解密速度。\n\nQ：解释tcp的三次握手以及双方状态的变化\n\nA：TCP的三次握手是在建立TCP连接时所执行的一种协议，用于确保通信的可靠性和双方都准备好传输数据。以下是TCP三次握手的过程和双方状态的变化：\n\n假设有两台设备，设备A和设备B，设备A希望与设备B建立TCP连接。\n\n 1. 第一次握手 (SYN)：\n    * 设备A向设备B发送一个特殊的TCP报文段，该报文段中设置了SYN标志位（即同步标志位）为1，并选择一个初始序列号（Sequence\n      Number）作为起始值。\n    * 此时，设备A进入\"SYN-SENT\"状态，表示已发送了连接请求。\n 2. 第二次握手 (SYN + ACK)：\n    * 设备B收到设备A发送的SYN报文段后，会对该连接请求进行响应。\n    * 设备B向设备A发送一个特殊的TCP报文段，其中设置了SYN和ACK标志位都为1，同时选择一个自己的初始序列号作为起始值，并且在ACK中确认收到了设备A的初始序列号+1。\n    * 此时，设备B进入\"SYN-RECEIVED\"状态，表示已收到连接请求并发送了连接确认。\n 3. 第三次握手 (ACK)：\n    * 设备A收到设备B发送的SYN + ACK报文段后，会对该连接确认进行响应。\n    * 设备A向设备B发送一个特殊的TCP报文段，其中设置了ACK标志位为1，并且在ACK中确认收到了设备B的初始序列号+1。\n    * 此时，设备A进入\"ESTABLISHED\"状态，表示连接已建立。\n 4. 设备B确认 (ESTABLISHED)：\n    * 设备B收到设备A发送的ACK报文段后，也进入\"ESTABLISHED\"状态。\n    * 此时，设备A和设备B之间的TCP连接已成功建立，双方可以开始进行数据传输。\n\n总结：在TCP三次握手中，设备A首先发送连接请求，设备B收到请求后发送连接确认，然后设备A收到确认后再发送最终确认。这样，双方都确认对方可以正常通信，并且双方都知道对方的初始序列号，从而确保了连接的可靠性。完成三次握手后，双方都进入\"ESTABLISHED\"状态，可以开始传输数据。\n\nQ：为什么是三次\n\nA：TCP采用三次握手的过程是为了确保连接的可靠性和避免出现旧连接请求被误认为是新连接的情况，同时也为了解决网络中可能存在的延迟、重复和乱序等问题。以下是解释为什么是三次握手的原因：\n\n 1. 避免旧连接请求的问题：在一个网络中，数据包可能会因为网络延迟或拥堵而导致延迟传送，TCP的三次握手可以确保旧的连接请求在一段时间后失效，防止旧的连接请求在网络中滞留，避免了类似的问题。\n 2. 确保双方都愿意建立连接：三次握手要求客户端和服务器都发送和接收连接请求和确认，这样可以确保双方都愿意建立连接。如果只有两次握手，那么可能出现以下情况：客户端发送连接请求，但是因为某种原因导致服务器没有收到，然后客户端再次发送请求建立连接，但此时服务器收到了第一个旧请求，然后误以为是客户端的新连接请求，从而建立了连接，而客户端并没有收到服务器的确认，从而无法建立连接。\n 3. 有效确认双方的初始序列号：TCP连接需要双方交换彼此的初始序列号，这个序列号用于后续数据的传输和包的排序。三次握手过程确保双方都得到了对方的确认，可以建立可靠的初始序列号。\n 4. 防止过期的连接请求：三次握手的过程可以有效地防止过期的连接请求在网络中产生混淆。如果只有两次握手，可能会因为网络延迟或乱序数据包而导致旧的连接请求在后续被误认为是新的连接请求。\n\n总结：TCP的三次握手过程是为了确保连接的可靠性和正确性，防止旧的连接请求导致的问题，并确保双方都愿意建立连接和得到了对方的确认。通过三次握手，TCP连接可以更可靠地建立起来，并保证了后续数据传输的正确性。\n\nQ：两次握手为什么无法确认初始序列号\n\nA：两次握手无法完全确认初始序列号的主要原因是缺乏对方的确认信息。\n\n在两次握手的场景下，设备A发送连接请求给设备B，并携带初始序列号。设备B收到连接请求后，确认了设备A的连接请求，但在这个阶段，设备B只发送了一个确认（ACK）报文段，而没有发送任何数据。因此，设备A并不能确定设备B的初始序列号，因为没有收到设备B发送的数据报文段。\n\n由于设备B没有发送数据，设备A不能知道设备B选择的初始序列号是什么。因此，在两次握手的情况下，初始序列号仍然存在不确定性，这会影响后续数据传输的正确性。\n\n为了解决这个问题，TCP采用了三次握手。在三次握手中，设备B在发送确认（ACK）报文段之前会先发送一个自己的连接请求，其中包含设备B的初始序列号。这样设备A收到设备B的连接请求后，会回复一个确认报文段，同时也发送了一个自己的连接请求，其中包含设备A的初始序列号。设备B收到设备A的确认后，可以确定设备A的初始序列号，因为设备B在回复确认时已经包含了设备A的初始序列号。通过这样的交互，双方都能确认对方的初始序列号，确保后续数据传输的正确性。\n\n因此，三次握手的过程比两次握手更可靠，可以有效解决初始序列号的确认问题，从而确保连接的安全性和可靠性。\n\n//这道题回答的不全面\n\n搞懂去看https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\n\nQ:详细解释TCP优雅断开连接的四次挥手\n\nA:TCP (Transmission Control Protocol) 是一种可靠的传输协议，用于在网络中传输数据。TCP\n优雅断开连接使用四次挥手过程来终止一个已建立的TCP连接。这四个步骤分别是：\n\n 1. 第一次挥手（FIN）： 客户端向服务器发送一个FIN（终止）标志，表示客户端已经没有数据要发送了，并请求关闭连接。\n 2. 第二次挥手（ACK）：\n    服务器收到客户端的FIN后，发送一个ACK（确认）标志作为响应。该ACK表示服务器已收到客户端的关闭请求，并且知道客户端将不再发送数据。\n 3. 第三次挥手（FIN）： 服务器向客户端发送一个FIN标志，表示服务器也没有数据要发送了，并请求关闭连接。\n 4. 第四次挥手（ACK）：\n    客户端收到服务器的FIN后，发送一个ACK作为确认。此ACK告诉服务器它已收到服务器的关闭请求，并且双方都知道连接将在这一点上关闭。\n\n下面是一个更详细的步骤说明：\n\n假设客户端为A，服务器为B。\n\n 1. A → B：发送FIN报文段 客户端A向服务器B发送一个带有FIN标志的TCP报文段。此时，A不再发送数据，但仍然可以接收来自B的数据。\n 2. B → A：发送ACK报文段\n    服务器B收到客户端A的FIN后，发送一个带有ACK标志的报文段作为确认。此时，服务器B进入半关闭状态，表示它不再发送数据，但仍然可以接收来自A的数据。\n 3. B → A：发送FIN报文段 一旦服务器B完成了它的数据传输任务，就会向客户端A发送一个带有FIN标志的报文段，表示它准备关闭连接。\n 4. A → B：发送ACK报文段\n    客户端A收到服务器B的FIN后，发送一个带有ACK标志的报文段作为确认。此时，客户端A进入TIME_WAIT状态。该状态是为了确保服务器B收到了ACK，以便在网络中的所有报文都被正确处理。\n\n完成以上四次挥手后，连接就会被正常关闭，A 和 B 都进入了 CLOSED 状态。\n\n这四次挥手过程确保了双方都知道彼此的关闭意图，并且能够完成未完成的数据传输，以便连接可以优雅地关闭而不会导致数据丢失。然而，TCP\n连接的关闭过程有时可能因为网络问题或其他原因而产生延迟，可以通过调整连接的超时参数来缓解一些潜在的问题。\n\nQ：为什么需要 TIME_WAIT 状态？\n\nA：TIME_WAIT 状态在 TCP 连接的关闭过程中扮演着重要的角色，其存在有以下主要原因：\n\n 1. 确保可靠关闭连接： TIME_WAIT 状态的最主要目的是确保双方都能可靠地关闭连接。在四次挥手过程中，客户端发送最后一个 ACK 后会进入\n    TIME_WAIT 状态，并且会在这个状态下等待一段时间。这样做的目的是为了确保服务器收到了客户端的 ACK 确认。服务器在接收到 ACK 后，也会进入\n    TIME_WAIT 状态，并等待一段时间。这样，双方在关闭连接后仍然保持着一段时间的通信状态，以处理可能在网络中滞留的报文。\n 2. 处理延迟报文： 在网络通信中，有可能会出现延迟到达的报文。当一端的 TCP\n    连接关闭后，可能还有一些数据报文在传输途中，这些报文可能在连接关闭之后到达。如果没有 TIME_WAIT\n    状态，服务器在关闭连接后立即释放资源，而收到的延迟报文会被丢弃，导致数据的丢失。通过等待一段时间进入 TIME_WAIT\n    状态，可以确保在这个状态下，双方能够处理掉所有滞留在网络中的报文，从而保证数据的完整性和可靠性。\n 3. 避免连接混淆： TCP 连接是通过源IP地址、源端口号、目标IP地址和目标端口号来标识的。在连接处于 TIME_WAIT\n    状态时，该连接的四元组（源IP、源端口、目标IP、目标端口）仍然是唯一的。如果不等待一段时间，而立即释放连接资源，有可能会导致在短时间内创建的新连接使用了之前的四元组，从而导致连接混淆和数据错乱。\n 4. 支持全双工关闭： TIME_WAIT\n    状态允许连接在全双工模式下完成关闭。全双工模式意味着两端的连接都能够同时关闭，而不会造成早期关闭的一方接收到错误的数据。通过 TIME_WAIT\n    状态，可以确保双方都能在正确的时间点关闭连接，而不会干扰对方的数据传输。\n\n尽管 TIME_WAIT 状态在一定程度上会增加系统资源的占用和延长连接关闭时间，但它对于TCP连接的可靠性和完整性至关重要。因此，在 TCP 协议中引入\nTIME_WAIT 状态是必要的，以保证网络通信的稳定性和可靠性。\n\nQ:TCP的概念\n\nA:TCP是\"传输控制协议\"（Transmission Control Protocol）的缩写。它是一种计算机网络通信协议，用于在网络中可靠地传输数据。\n\nTCP是互联网协议套件中的一个重要组成部分，与IP（Internet\nProtocol，互联网协议）一起构成了TCP/IP协议栈。TCP负责在数据通信的两个应用程序之间提供可靠的、有序的、面向连接的数据传输。\n\n下面是TCP的一些关键概念：\n\n 1. 可靠性： TCP确保数据的可靠传输，它通过使用确认（acknowledgments）和重传机制来检测和纠正数据传输中可能出现的错误或丢失。\n 2. 面向连接： 在数据传输之前，TCP会在通信双方建立一个连接。这个连接是可靠的、有序的、全双工的通信通道。数据传输完成后，连接会被显式地释放。\n 3. 流控制： TCP使用流控制机制来确保发送方不会发送过多的数据，以防接收方处理不过来。这可以避免数据丢失或拥塞的情况。\n 4. 拥塞控制： TCP通过拥塞控制算法来防止网络拥塞，确保在网络不稳定或拥塞时适当地降低发送速率，从而维持网络的稳定性和公平性。\n 5. 数据分段和重组： TCP会将应用层传输的数据划分为小块，称为数据段（segment），然后在接收方重新组装这些数据段，以确保可靠性和有序性。\n 6. 端口： TCP使用端口号来标识不同的应用程序或服务。在数据传输中，源和目标端会使用不同的端口号来区分应用程序或服务。\n\n总体而言，TCP是一种可靠的、面向连接的协议，适用于对数据传输有较高要求的应用，例如文件传输、网页浏览、电子邮件等。它是互联网通信中的基础之一，为数据在网络中的传输提供了稳定的基础。\n\nQ:UDP的概念\n\nA:UDP是\"用户数据报协议\"（User Datagram\nProtocol）的缩写。它也是一种计算机网络通信协议，与TCP一样属于互联网协议套件中的一部分，但与TCP不同，UDP提供了一种无连接的、不可靠的数据传输方式。\n\n下面是UDP的一些关键概念：\n\n 1. 无连接性： UDP是无连接的协议，这意味着在数据传输之前不会建立像TCP那样的连接。发送方直接将数据报发送给接收方，而无需预先建立通信通道。\n 2. 不可靠性：\n    UDP不提供数据传输的可靠性保证。一旦数据报发送出去，UDP不会等待确认或进行重传，因此无法确保数据的完整性和可靠性。如果数据丢失或出现错误，UDP将不做任何处理。\n 3. 数据分组：\n    UDP将应用层传输的数据划分为小的数据报，称为数据报文（datagram）。这些数据报可以独立地发送和接收，因此在接收端可能会以不同的顺序或多次接收到它们。\n 4. 低延迟： 由于UDP没有建立连接和确认机制，它的处理速度更快，因此具有较低的传输延迟。这使得UDP适用于实时性要求较高的应用，如语音通话、视频流等。\n 5. 简单性： 相对于TCP，UDP的实现和处理较为简单，因为它不需要维护连接状态、执行流控制和拥塞控制等复杂的机制。\n\nUDP在一些特定场景下非常有用，例如在实时应用中，它可以快速传输数据并允许丢失一些数据，而不会对应用造成明显的影响。然而，由于其不可靠性，如果应用需要确保数据的完整性和可靠性，通常会选择使用TCP来进行数据传输。\n\nQ:TCP和UDP的区别\n\nA:TCP（传输控制协议）和UDP（用户数据报协议）是两种不同的传输层协议，在计算机网络中有以下主要区别：\n\n 1. 连接性：\n    * TCP是面向连接的协议。在数据传输之前，发送方和接收方需要建立一个连接，然后进行数据传输，最后释放连接。这种连接过程保证了数据传输的可靠性和有序性。\n    * UDP是无连接的协议。发送方不需要在传输数据之前建立连接，直接发送数据包到目的地。由于没有连接的建立和释放过程，UDP在传输过程中的开销较小。\n 2. 可靠性：\n    * TCP提供可靠的数据传输。它使用确认和重传机制来确保数据的完整性和准确性。如果数据包丢失或损坏，TCP会重新发送这些数据包，直到接收方正确地收到它们为止。\n    * UDP提供非可靠的数据传输。它不使用确认和重传机制，因此在传输过程中可能会丢失数据包或以不同的顺序到达目的地。UDP适用于那些对实时性要求较高、能容忍一定数据丢失的应用，但不适合要求数据完整性的应用。\n 3. 传输效率：\n    * TCP的可靠性和连接管理会导致一定的传输开销，使其传输效率相对较低。此外，TCP的拥塞控制机制会导致数据传输速率在网络拥塞时降低，以避免网络丢包过多。\n    * UDP的传输效率较高，因为它没有连接建立和断开的开销，也没有拥塞控制，数据包的传输速率更为稳定。但这也意味着在网络不稳定或拥塞时，UDP可能会遇到更多的数据丢失。\n 4. 应用场景：\n    * TCP适用于那些对数据传输可靠性要求较高的应用，例如文件传输、电子邮件、网页浏览等。由于TCP可以确保数据的完整性和顺序，它是大部分互联网应用的首选协议。\n    * UDP适用于对传输速度和实时性要求较高的应用，例如实时视频和音频传输、在线游戏等。在这些应用中，及时传输数据比绝对的数据可靠性更重要。\n\n总结：\nTCP是一种可靠的、面向连接的协议，适用于需要数据完整性的应用；而UDP是一种快速的、无连接的协议，适用于实时性要求高、对数据完整性要求相对较低的应用。在选择使用TCP或UDP时，需要根据具体应用的需求来决定。\n\nQ:TCP和UDP的应用场景\n\nA:CP和UDP在网络通信中有不同的应用场景，因为它们具有不同的特性。下面列举了一些常见的TCP和UDP应用场景：\n\nTCP 的应用场景：\n\n 1. 网页浏览：当您访问网页时，使用TCP来下载网页的文本、图像和其他资源。TCP的可靠性确保网页内容正确地显示在您的浏览器上。\n 2. 文件传输：在需要确保文件传输完整性的情况下，如从服务器下载大型文件或通过FTP（文件传输协议）上传文件，TCP是首选协议。\n 3. 电子邮件：电子邮件的传输需要可靠性，因为丢失或损坏邮件可能导致信息丢失。因此，SMTP（简单邮件传输协议）和POP3（邮局协议版本3）等电子邮件协议使用TCP。\n 4. 远程访问：当用户远程访问服务器或使用远程桌面时，需要稳定的连接和可靠的数据传输，TCP提供了这种可靠性。\n 5. 加密通信：一些加密协议，如HTTPS（HTTP安全）使用TCP作为传输层，以确保安全的数据传输，比如网上银行或安全登录。\n\nUDP 的应用场景：\n\n 1. 实时音视频通信：视频聊天、语音通话、视频会议等需要实时性的应用通常使用UDP。虽然UDP不保证数据的可靠传输，但在实时应用中，速度和实时性比数据的可靠性更重要。\n 2. 在线游戏：网络游戏通常使用UDP，因为游戏需要快速的数据传输，较小的延迟和对数据丢失的容忍度，这些都是UDP的特点。\n 3. DNS（域名系统）：DNS用于将域名解析为IP地址，这样您可以通过域名访问网站。DNS查询通常使用UDP，因为查询速度比可靠性更重要。\n 4. 实时广播：在需要将数据快速传输到多个接收方的场景中，例如视频直播或多媒体广播，UDP能够提供更高效的数据传输。\n\n总结：\nTCP适用于需要数据可靠性的场景，如网页浏览、文件传输和电子邮件。UDP适用于实时性要求高、能容忍一定数据丢失的场景，如实时音视频通信、在线游戏和实时广播。根据应用的特定需求，选择合适的协议对于实现最佳性能和用户体验非常重要。\n\nQ：TCP的可靠传输机制\n\nA：TCP (Transmission Control Protocol)\n是一种面向连接的、可靠的传输协议，用于在计算机网络中传输数据。TCP的可靠传输机制是确保数据在发送和接收之间的可靠传递的方式。下面是TCP实现可靠传输的主要机制：\n\n 1. 确认和序列号：TCP使用序列号和确认机制来保证数据的有序传输和可靠接收。发送方将每个数据段进行编号（序列号），接收方在收到数据段后会发送确认消息，并指定下一个期望收到的数据段的序列号。如果发送方在合理的时间内未收到确认消息，它会重新发送数据。\n 2. 重传机制：如果发送方未收到对特定数据段的确认消息，它会假设该数据段在传输过程中丢失，并触发重传。接收方在收到重复的数据段时会自动丢弃重复的部分，以保证数据的正确性。\n 3. 流量控制：TCP使用滑动窗口协议来控制发送方发送数据的速率，以避免数据的过度发送导致接收方缓冲区溢出。接收方会通知发送方当前可用的缓冲区大小，发送方根据这个信息来调整发送速率。\n 4. 拥塞控制：TCP使用拥塞控制算法来避免网络拥塞并确保公平共享网络带宽。如果网络拥塞或出现丢包，TCP会降低发送速率以减少网络负载，然后逐渐增加发送速率，以便在不引起拥塞的情况下尽可能利用可用带宽。\n 5. 超时和重试：TCP通过设置定时器来监测数据发送的确认状态。如果定时器超时，发送方会认为数据丢失，并重新发送这些数据。\n 6. 有限等待时间：TCP规定了一个有限的等待时间来处理数据的重传和确认，以避免数据在网络中长时间滞留。\n\n这些机制共同确保了TCP的可靠性，使其成为许多应用程序中传输数据的首选协议，例如网页浏览、电子邮件传输、文件下载等。\n\nQ：细说拥塞控制\n\nA：拥塞控制是TCP协议中的重要机制，用于避免网络拥塞，确保网络资源合理分配，以及保持整个网络的稳定性和高效性。TCP通过以下几种拥塞控制算法来应对不同的网络拥塞情况：\n\n 1. 慢开始和拥塞避免：TCP连接刚开始时，发送方会采用慢开始算法，即初始发送窗口大小较小。发送方在每次接收到一个确认时，将发送窗口大小加倍，这样在开始阶段，数据发送速率会呈指数级增长。但是，当网络拥塞开始出现时，为了避免过多的数据注入网络，TCP就会进入拥塞避免状态。在拥塞避免状态下，发送方每收到一个确认，发送窗口的大小增加变得更慢，是线性增加而不是指数增加。这样就可以避免快速导致拥塞的情况。\n 2. 快重传和快恢复：为了更快地恢复丢失的数据段，TCP采用了快重传和快恢复算法。当接收方收到失序的数据段时，它会立即发送对已经接收到的最后一个有序数据段的确认。这样发送方就能立即知道有数据段丢失，并进行快速重传，而不用等待超时。快恢复算法允许发送方在接收到快重传的确认后，将拥塞窗口减半，然后进入拥塞避免状态，而不是慢开始状态，以更快地恢复发送速率。\n 3. 超时重传：如果发送方发送的数据在一定的时间内（超时时间）没有收到确认，那么发送方会认为这些数据丢失，并触发超时重传。在出现超时重传时，TCP会将拥塞窗口设置为1，并重新开始执行慢开始算法。\n 4. 拥塞窗口：拥塞窗口是发送方在一个往返时间（Round Trip\n    Time，RTT）内允许发送的最大数据量。TCP的发送速率取决于拥塞窗口的大小。当网络拥塞时，发送方会根据拥塞控制算法调整拥塞窗口的大小，以限制数据注入网络的速率。\n 5. 确认阈值：当发生超时重传时，TCP会将拥塞窗口减少到一个较小的值，称为确认阈值（ssthresh）。发送方在慢开始和拥塞避免状态下，当拥塞窗口大小达到确认阈值时，切换到拥塞避免状态。\n\n这些算法和机制使得TCP能够对网络拥塞做出敏感的反应，控制发送速率，并在网络拥塞出现时进行适当的调整，从而避免过载导致的丢包和网络崩溃。这些拥塞控制算法共同构成了TCP的可靠性和稳定性的基础，使得TCP在互联网中成为主流的传输协议。\n\nQ:DNS的完整查询过程\n\nA:DNS（Domain Name\nSystem）是用于将域名解析为IP地址的系统。当您在浏览器中输入一个域名时，系统会执行完整的DNS查询过程，以获取与该域名相关联的IP地址。以下是DNS的完整查询过程：\n\n 1. 本地域名解析器查询：\n    当您在浏览器中输入一个域名时，首先会向本地计算机或设备上的本地域名解析器（通常由您的ISP提供）发送查询请求。该解析器通常是您的路由器或操作系统的一部分。\n 2. 本地域名解析器缓存查询：\n    本地域名解析器会首先检查是否已经缓存了该域名的IP地址。如果之前已经查询过该域名，并且缓存的数据还没有过期，那么解析器将直接返回缓存的IP地址，无需进行后续查询。\n 3. 根域名服务器查询：\n    如果在本地域名解析器的缓存中找不到对应的IP地址，解析器将会向根域名服务器发送查询请求。根域名服务器是DNS层次结构的最高层，其数量有限且固定。\n 4. 顶级域名服务器查询：\n    根域名服务器不会直接返回域名的IP地址，而是会指示本地域名解析器去查询对应的顶级域名服务器。顶级域名服务器负责管理特定顶级域（如.com、.org、.net等）下的所有子域。\n 5. 权威域名服务器查询： 顶级域名服务器会指示本地域名解析器查询该域名的权威域名服务器。权威域名服务器是负责管理该域名的DNS记录的服务器。\n 6. 查询结果返回：\n    本地域名解析器通过向权威域名服务器发送查询请求，获取到域名对应的IP地址。一旦本地域名解析器收到IP地址，它会将其存储在缓存中，并将IP地址返回给您的计算机或设备。\n 7. 访问目标服务器：\n    现在，您的计算机或设备已经知道了域名对应的IP地址。它会使用这个IP地址与目标服务器建立连接，然后向该服务器发送HTTP请求，以获取所需的网页内容或其他资源。\n\n值得注意的是，DNS查询结果会被缓存，这样在一定的时间范围内，再次查询相同的域名时就不需要再执行完整的查询过程，从而加快访问速度。DNS的缓存过程在多个层级上都有，从本地解析器的缓存到根域名服务器和顶级域名服务器的缓存，以及权威域名服务器自身的缓存。\n\nQ：dns同时使用tcp和udp协议？\n\nA：是的，域名系统 (DNS) 可以使用 TCP（传输控制协议）和 UDP（用户数据报协议）作为其传输协议，具体取决于具体的用例和环境。\n\nUDP 是 DNS 查询的默认且最常用的传输协议。 它是一种无连接协议，这意味着它在发送数据之前不会建立持久连接。 UDP 通常用于标准 DNS\n查询和响应，因为与 TCP 相比，它更快并且需要更少的开销。 然而，UDP 由于其固定报头较小，因此在消息大小上有限制（通常为 512 字节）。\n\n另一方面，TCP 是一种面向连接的协议，它在传输数据之前建立可靠且有序的连接。 当数据大小超过 UDP 的最大限制或需要称为“DNS 区域传输”的功能时，它用于\nDNS 查询和响应。 DNS 区域传输用于在 DNS 服务器之间复制 DNS 数据库，以实现冗余和负载平衡目的。\n\n以下是 DNS 可能使用 TCP 的一些场景：\n\n 1. 大型 DNS 响应：当 DNS 响应数据大小超过 512 字节的 UDP 限制（对于传统 DNS）或更高的 EDNS0 限制（对于现代\n    DNS）时，DNS 服务器将切换到 TCP 以确保可靠的数据传输。\n 2. 区域传输：DNS 区域传输涉及权威 DNS 服务器之间 DNS 数据库信息的传输。 此过程通常通过 TCP 完成，以确保数据完整性和可靠性。\n 3. DNSSEC（DNS 安全扩展）：DNSSEC 通过对 DNS 数据进行加密签名，为 DNS 添加了额外的安全层。 DNSSEC 签名的响应通常比传统的\n    DNS 响应大，并且在某些情况下，它们需要 TCP。\n 4. 由于网络配置或特定要求，DNS 服务器首选 TCP 的任何其他情况。\n\n在大多数情况下，标准 DNS 查询和响应通过 UDP 进行以提高效率，但在需要时 TCP 始终可用作后备选项。 DNS 解析器和客户端旨在处理 UDP 和\nTCP，以确保与 DNS 服务器的顺利通信。\n\nQ：DNS记录和报文？\n\nA：DNS (Domain Name System) 是一个用于将域名转换为 IP\n地址的分布式系统。它使我们能够使用人类可读的域名（例如www.example.com）来访问 Internet 上的资源，而无需记住其对应的 IP 地址。\n\nDNS 记录和报文是 DNS 系统中的两个重要概念：\n\n 1. DNS 记录： DNS 记录是存储在 DNS 服务器上的数据项，用于指定特定域名的相关信息，如域名对应的 IP\n    地址、邮件服务器等。每个域名可以有多个不同类型的 DNS 记录。常见的 DNS 记录类型包括：\n\n * A 记录：将域名映射到 IPv4 地址。\n * AAAA 记录：将域名映射到 IPv6 地址。\n * CNAME 记录：将域名映射到另一个域名，用于创建域名的别名。\n * MX 记录：指定邮件服务器的优先级和地址，用于电子邮件传递。\n * TXT 记录：允许管理员在域名中添加任意文本信息。\n\n通过查询 DNS 服务器，可以获取与特定域名相关的记录，从而找到相应的 IP 地址或其他相关信息。\n\n 1. DNS 报文： DNS 报文是在 DNS 查询和响应之间传输的数据格式。当计算机需要解析特定域名的 IP 地址时，它会向本地 DNS 服务器发送 DNS\n    查询报文。这个查询报文中包含了查询的域名以及所需的记录类型（如 A 记录或 MX 记录等）。\n\n本地 DNS 服务器收到查询报文后，它会检查自己的缓存，看是否已经有该域名的解析结果。如果缓存中没有记录，本地 DNS 服务器将作为中继，向更高级别的 DNS\n服务器发送查询请求。\n\n一般情况下，DNS 查询会经过多个层次的 DNS 服务器，直至找到包含所需记录的权威 DNS 服务器。然后，权威 DNS 服务器将发送 DNS\n响应报文回到发起查询的本地 DNS 服务器，最终返回给计算机。\n\nDNS 报文的格式遵循特定的协议标准，其中包含头部信息和查询/响应部分，用于描述域名查询和响应的详细信息。\n\n总结：DNS 记录是存储在 DNS 服务器上的域名相关信息，而 DNS 报文是在 DNS 查询和响应之间传输的数据格式。通过组合使用这两个概念，DNS\n系统能够为我们提供域名解析和资源定位的功能。\n\nQ：常见的HTTP请求方法\n\nA：HTTP（超文本传输协议）定义了多种方法或动词，用于指定要对资源执行的所需操作。 这些方法用在 HTTP 请求-响应周期的请求部分。 最常见的 HTTP\n方法是：\n\n 1. GET：用于从服务器检索数据。 服务器在响应正文中使用请求的数据进行响应。 GET 请求不应对服务器产生任何副作用，这意味着它们不应修改数据。\n 2. POST：用于将需要处理的数据提交到指定的资源。 它通常用于在服务器上创建新资源或提交表单数据。 POST\n    请求可能会对服务器产生副作用，例如创建或更新数据。\n 3. PUT：用于更新服务器上的资源。 它指定资源的 URI（统一资源标识符）并在请求正文中提供资源的新表示形式。\n 4. DELETE：用于请求从给定 URI 标识的服务器中删除资源。\n 5. PATCH：与PUT类似，但它只更新资源的指定字段，而不是替换整个资源。\n 6. HEAD：与 GET 类似，但只返回响应头，不返回响应体。 它对于在实际检索资源之前检查元数据（例如，内容类型、内容长度）很有用。\n 7. OPTIONS：用于请求有关目标资源可用的通信选项的信息。 它有助于确定服务器支持哪些 HTTP 方法和标头。\n 8. TRACE：主要用于诊断目的。 它回显收到的请求，允许客户端查看哪些中间服务器修改了请求。\n 9. CONNECT：主要用于通过代理服务器建立到资源的网络连接。 它通常在 HTTPS 协议上下文中用于创建隧道。\n\n请注意，并非所有 Web 服务器和应用程序都支持所有这些方法，并且它们的使用可能会根据应用程序的设计和安全考虑因素而有所不同。 安全方法（GET 和\nHEAD）通常用于只读操作，而其他方法则用于修改服务器上的资源或与服务器上的资源交互。\n\nQ:GET和POST的区别\n\nA:GET 和 POST 是用于客户端-服务器通信的两种最常见的 HTTP 方法。 它们具有不同的用途和特征，了解它们的差异对于在 Web\n应用程序中正确使用至关重要。\n\n 1. 目的：\n    * GET：GET 方法主要用于从服务器检索数据。 它将参数附加到 URL 的查询字符串中，并且对用户可见。 它通常用于只读操作，对同一 URL 的多个\n      GET 请求不应该对服务器产生任何副作用。\n    * POST：POST方法用于向服务器提交数据，通常用于创建或更新服务器上的资源。 它在请求正文中发送数据，使其更适合不应在 URL\n      中公开的敏感数据或大数据。\n 2. 数据可见性：\n    * GET：通过 GET 请求发送的数据在 URL 的查询字符串中可见。 这意味着密码或个人身份数据等敏感信息不应包含在 GET\n      请求中，因为这些信息可以在浏览器历史记录、服务器日志中轻松查看，并且可以添加书签。\n    * POST：通过 POST 请求发送的数据在 URL 中不可见，这使其成为传递敏感信息的更安全的方法。\n 3. 数据长度：\n    * GET：由于数据附加在 URL 上，因此可以发送的数据长度有限制。 不同的浏览器和服务器有不同的限制，但通常建议保持数据简短并在几千字节以内。\n    * POST：作为请求正文的一部分，POST 请求可以处理大量数据。 该限制通常远高于 GET 请求的限制，从而允许传输更大的有效负载。\n 4. 缓存：\n    * GET：浏览器可以缓存 GET 请求，从而使对同一 URL 的后续请求更快，因为可以重用缓存的响应。\n      但是，这意味着缓存的数据可能并不总是反映服务器上的最新信息。\n    * POST：POST请求默认不被缓存，这样可以保证数据始终发送到服务器，并且服务器可以对数据进行相应的处理。\n 5. 幂等性：\n    * GET：GET 请求被认为是幂等的，这意味着多次发出相同的 GET 请求将与发出一次具有相同的效果。 它不应改变服务器的状态或产生任何副作用。\n    * POST：POST 请求不是幂等的，多次发出相同的请求可能会导致服务器上同一资源的多次创建或更新。\n\n总之，使用 GET 进行安全、只读操作，使用 POST 进行涉及数据提交或修改的操作，尤其是在处理敏感或大数据时。\n\nQ:POST和PUT的区别\n\nA:POST和PUT是两种HTTP方法，用于在Web应用程序中向服务器提交数据或更新资源。它们之间的主要区别如下：\n\n 1. 目的：\n    * POST：用于向服务器提交新数据，通常用于创建新资源。\n    * PUT：用于向服务器更新已有资源或创建新资源。PUT被认为是幂等的，这意味着多次对同一资源的PUT操作不会导致不同的结果。\n 2. 幂等性：\n    * POST：不是幂等的。多次对同一资源的POST请求可能会导致服务器创建多个相同的资源副本。\n    * PUT：是幂等的。多次对同一资源的PUT请求不会导致重复创建或更改，其结果保持一致。\n 3. 数据传递：\n    * POST：通常将数据作为请求的主体（payload）传递，可以用于创建资源或提交表单数据。\n    * PUT：也将数据作为请求的主体传递，但通常用于更新现有资源。\n 4. URL使用：\n    * POST：通常在URL中指定目标资源的集合，而不是具体的资源。例如：POST /items表示在/items集合中创建一个新的资源。\n    * PUT：URL通常指定要更新的特定资源。例如：PUT /items/123表示更新ID为123的/items资源。\n 5. 安全性：\n    * POST：不是安全的方法，因为它可能会导致新资源的创建，对服务器状态产生影响。\n    * PUT：不是安全的方法，因为它可能会更改或创建资源。\n\n总结：\n\n * 使用POST时，通常是在服务器上创建新资源或处理需要提交到服务器的表单数据。\n * 使用PUT时，通常是在服务器上更新现有资源或者创建新资源，同时在已知资源的情况下也可以用于创建新资源。\n\n在设计RESTful API时，正确使用这些HTTP方法是非常重要的，因为它们有助于确保服务器端行为的一致性和可预测性。\n\nQ:介绍HTTP请求方法的OPTION方法及其使用场景\n\nA:HTTP的OPTIONS方法是一种请求方法，它用于向服务器查询特定资源支持的各种请求方法。该方法不会对服务器资源产生实际的影响，而是用于获取有关服务器资源的信息。\n\n当客户端发送一个OPTIONS请求时，服务器将会返回包含允许的HTTP方法的列表，以及其他相关的信息，如允许的请求头部、认证要求等等。这样，客户端就可以在实际发送其他请求之前，了解服务器支持哪些方法和配置，从而进行适当的请求。\n\n使用场景：\n\n 1. 支持跨域资源共享（CORS）：当浏览器使用XMLHttpRequest或Fetch\n    API等方式跨域请求资源时，会先发送一个OPTIONS请求给服务器，询问服务器是否支持跨域请求。服务器通过OPTIONS请求返回相应的CORS头部信息，以决定是否允许该跨域请求。\n 2. 了解服务器支持的请求方法：OPTIONS方法可以用于在不发送其他请求之前，查询服务器对资源支持的请求方法。这对于了解服务器配置和限制很有用。\n 3. 服务发现：在一些RESTful\n    API中，服务器可能提供服务发现功能，客户端可以通过OPTIONS方法来获取API的信息，包括可用的资源、支持的方法和相关的URL等。\n 4. API文档生成：在API文档自动生成的过程中，可以使用OPTIONS方法来探测API中可用的资源和方法，然后将其整理为文档供开发者查阅。\n\n总之，OPTIONS方法是一个用于探测服务器资源支持情况的查询工具，通过发送OPTIONS请求，可以获取服务器对资源的配置信息，进而更好地与服务器进行交互。\n\nQ：HTTP常见的请求头和响应头\n\nA：HTTP (Hypertext Transfer Protocol) 是一种用于传输数据的协议，它在客户端和服务器之间进行通信。HTTP\n请求和响应都包含一系列的请求头和响应头，这些头部提供了关于请求或响应的信息。下面是一些常见的 HTTP 请求头和响应头：\n\n常见的HTTP请求头：\n\n 1. User-Agent: 标识发送请求的用户代理（浏览器、应用程序等）的信息，服务器可以根据此信息进行适当的响应。\n 2. Accept: 告诉服务器客户端可以接受的内容类型（MIME 类型），通常用于请求特定的文件格式，如图片、视频等。\n 3. Content-Type: 定义请求体中发送数据的类型（MIME 类型），告诉服务器如何解析请求的主体部分。\n 4. Authorization: 用于在请求中发送用户的身份验证凭据，如用户名和密码，通常用于进行基本认证或 Bearer Token 认证。\n 5. Cookie: 用于在请求中发送保存在客户端的 Cookie 数据，服务器可以根据其中的信息进行用户跟踪和状态管理。\n 6. Referer: 指示当前请求是从哪个页面或URL链接过来的，用于追踪请求来源。\n 7. Host: 指定请求的主机名，用于虚拟主机的访问，即在一个服务器上托管多个网站。\n 8. Origin: 表示请求的来源，主要用于跨站点请求防伪 (CSRF)。\n\n常见的HTTP响应头：\n\n 1. Content-Type: 定义响应主体中数据的类型（MIME 类型），告诉客户端如何解析响应的内容。\n 2. Content-Length: 指示响应主体的长度，用于确定数据的传输结束点。\n 3. Server: 表明响应的服务器名称和版本。\n 4. Set-Cookie: 用于在响应中设置 Cookie 数据，将数据保存在客户端。\n 5. Location: 通常与状态码 3xx 一起使用，用于重定向到新的URL。\n 6. Cache-Control: 指定响应的缓存策略，如缓存时间、是否允许缓存等。\n 7. Expires: 指定响应的过期时间，用于控制缓存时长。\n 8. Access-Control-Allow-Origin: 用于跨域请求，指定哪些域名可以访问该资源。\n\n这只是一小部分常见的HTTP请求头和响应头，HTTP 协议有许多其他头部，用于传递各种不同的信息，具体的使用取决于应用程序的需求和场景。\n\nQ:HTTP状态码304\n\nA:HTTP状态码304表示\"未修改\"（Not\nModified）。它是HTTP协议中的一个状态码，用于指示客户端发送了一个条件性请求，但服务器判断所请求的资源在上次请求之后没有修改，因此可以直接使用缓存的版本，无需返回实际的资源内容。\n\n当客户端向服务器发送一个GET请求（通常是带有条件头部，如If-Modified-Since或If-None-Match）时，服务器会检查该请求所对应的资源是否有过修改。如果服务器发现资源没有修改，它会返回状态码304\nNot Modified，而不是返回200 OK和资源的实际内容。这样，客户端就可以继续使用缓存的版本，节省了网络带宽和服务器的处理开销。\n\n状态码304的响应中通常不包含实际的资源内容，而是在响应头中包含一些与缓存相关的信息，例如新的过期时间和ETag（资源的标识符），这些信息有助于客户端在未来的请求中进一步优化缓存机制。\n\n总结一下，HTTP状态码304表示资源未修改，客户端可以继续使用缓存的版本而无需重新下载该资源。\n\nQ:HTTP1.0和HTTP1.1的区别\n\nA：HTTP（超文本传输协议）是一种用于通过互联网传输数据的协议，通常用于访问网站。 HTTP 经历了多个版本，其中最重要的两个版本是 HTTP/1.0 和\nHTTP/1.1。 以下是 HTTP/1.0 和 HTTP/1.1 之间的主要区别：\n\n 1. 持久连接：\n    * HTTP/1.0：默认情况下，每个 HTTP 请求/响应都是使用单独的连接进行的。 这意味着每次请求后，连接都会关闭，并为下一个请求建立新连接。\n    * HTTP/1.1：引入了持久连接的概念，也称为保活连接。 使用 HTTP/1.1，可以通过同一 TCP 连接发送和接收多个请求和响应。\n      这有助于减少为每个请求建立和关闭连接的开销，从而加快具有多个资源的网站的加载时间。\n 2. 流水线：\n    * HTTP/1.0：不支持请求管道。 这意味着客户端无法在不等待响应的情况下通过单个连接发送多个请求。\n    * HTTP/1.1：引入了请求管道的概念，允许客户端发送多个请求而无需等待相应的响应。 这有助于提高连接的整体效率并减少延迟。\n 3. 主机头：\n    * HTTP/1.0：请求中未包含主机标头。 不直接支持虚拟主机（在同一 IP 地址上托管多个网站）。\n    * HTTP/1.1：在每个请求中强制使用 Host 标头。 这使得 Web 服务器能够区分同一 IP\n      地址上的不同虚拟主机，并将请求正确路由到适当的网站。\n 4. 缓存：\n    * HTTP/1.0：对缓存的支持有限，并且缓存行为在不同服务器和客户端之间的实现不一致。\n    * HTTP/1.1：引入了更强大的缓存机制。\n      它添加了缓存控制标头，例如“Cache-Control”和“ETag”，允许服务器向客户端清楚地传达缓存指令，从而提高了缓存效率。\n 5. 分块传输编码：\n    * HTTP/1.0：不支持分块传输编码，这是一种在不提前指定内容长度的情况下以块的形式发送数据的方式。\n    * HTTP/1.1：增加了对分块传输编码的支持，能够高效传输大量数据和动态内容。\n 6. 范围要求：\n    * HTTP/1.0：不支持部分或范围请求。 如果您只想下载文件的一部分，则必须获取整个文件。\n    * HTTP/1.1：引入了对范围请求的支持，允许客户端请求资源的特定部分，这对于恢复中断的下载和优化网络使用特别有用。\n\nHTTP/1.1 相对于 HTTP/1.0 带来了一些改进，主要集中在性能、效率以及对现代 Web 应用程序的更好支持。 然而，随着 HTTP/2 和\nHTTP/3 的出现，在性能、多路复用和安全性方面取得了更显着的进步。\n\nQ：HTTP1.1和HTTP2.0的区别\n\nA：HTTP/1.1 和 HTTP/2.0 是超文本传输协议 (HTTP) 的两个版本，用于客户端（例如 Web 浏览器）和 Web 服务器之间的通信。\n以下是两个版本之间的一些主要区别：\n\n 1. 二进制与文本协议 ：\n    * HTTP/1.1 是基于文本的协议，这意味着客户端和服务器之间发送的标头和数据采用人类可读的格式。\n      这使开发人员可以轻松检查通信，但由于文本冗长，可能会导致更大的数据传输。\n    * 另一方面，HTTP/2.0 使用二进制帧，这意味着标头和数据以二进制格式发送。 这样可以实现更高效、更紧凑的数据传输，减少延迟并提高性能。\n 2. 多路复用 ：\n    * 在 HTTP/1.1 中，从客户端到服务器的多个请求通常通过单个连接顺序处理。 这可能会导致“队头阻塞”，即缓慢加载的资源会延迟后续资源的加载。\n    * HTTP/2.0 引入了多路复用，允许通过单个连接同时发送和接收多个请求和响应。 这可以实现并行性并消除队头阻塞问题，从而缩短页面加载时间。\n 3. 服务器推送 ：\n    * HTTP/1.1 要求客户端显式请求呈现网页所需的每个资源。 如果服务器想要发送未请求的其他资源，则必须等待客户端请求它们。\n    * HTTP/2.0支持服务器推送，服务器无需显式请求即可主动推送资源给客户端。\n      这可以导致更快的页面加载，因为服务器可以预测客户端的需求并提前发送资源。\n 4. 标头压缩 ：\n    * HTTP/1.1 标头随每个请求和响应一起发送，这可能会导致不必要的开销，特别是在重复类似标头时。\n    * HTTP/2.0 使用标头压缩，可以减小标头的大小，优化数据传输并进一步提高性能。\n 5. 连接管理 ：\n    * HTTP/1.1 需要多个连接（通常限制为六个）来并行加载资源，这可能效率低下。\n    * HTTP/2.0 每个客户端和域仅需要一个连接，从而更好地利用资源并简化连接管理。\n 6. 优先顺序 ：\n    * HTTP/2.0 允许客户端为各个资源分配优先级，表明它们的重要性，并允许服务器首先提供更高优先级的资源。\n\n总而言之，HTTP/2.0 旨在解决 HTTP/1.1 的局限性，特别是在性能、延迟和资源加载效率方面。 它对其前身进行了重大改进，使网页浏览更快、更高效。\n然而，值得注意的是，HTTP/2.0 的采用需要 Web 服务器和客户端（例如 Web 浏览器）的支持，尽管大多数现代浏览器和服务器现在都支持它。\n\nQ：为什么HTTP的GET方法有长度限制？\n\nA：HTTP 的 GET 方法对 URL 的长度有限制，这最终会影响单个请求中可以发送的数据量。 此限制是由多种因素造成的：\n\n 1. URL 长度限制：HTTP 协议没有对 URL 的长度定义具体限制。 相反，它由各个网络浏览器和服务器来确定。 然而，实际上，出于实用和安全原因，许多\n    Web 浏览器和服务器都规定了最大 URL 长度。 实际限制可能因浏览器、服务器软件和其他因素而异。\n 2. 服务器和代理限制：Web 服务器和代理也对 URL 长度施加了自己的限制。 例如，Apache 或 Nginx 等服务器软件可能具有限制请求中允许的最大\n    URL 长度的配置设置。\n 3. 安全问题：限制 URL 的长度有助于防止某些类型的攻击，例如缓冲区溢出攻击和拒绝服务 (DoS) 攻击。\n    通过施加最大长度，服务器可以更有效地分配资源并降低滥用风险。\n 4. 编码开销：在 HTTP 请求中，URL 中的特殊字符和空格必须使用百分比编码（也称为 URL 编码）进行编码。\n    此编码引入了额外的字符来表示特殊字符，这会增加 URL 的整体长度。\n 5. 实际注意事项：长 URL 可能难以管理、共享和添加书签。 用户在复制或粘贴长 URL 时可能会遇到问题，并且某些网站可能对其接受的 URL 长度有限制。\n\n由于这些原因，HTTP 的 GET 方法对请求中可以使用的 URL 的长度有固有的限制。 当需要发送大量数据时，通常使用 HTTP POST 方法作为替代方法。\nPOST 请求可以在请求正文中包含数据，与 GET 请求相比，允许更大的有效负载。\n\nQ：HTTP的keep-alive\n\nA：HTTP Keep-Alive，也称为持久连接或 HTTP 持久连接，是 HTTP 协议的一项功能，允许通过单个\nTCP（传输控制协议）连接发送和接收多个请求和响应。 默认情况下，HTTP 是无状态协议，这意味着客户端（例如 Web\n浏览器）和服务器之间的每个请求和响应独立于任何先前或后续请求和响应。\n\n使用 HTTP Keep-Alive，在初始请求和响应完成后，TCP 连接保持打开状态，允许后续请求重用同一连接，而不是为每个后续 HTTP\n请求建立一个新连接。 这可以提供几个好处：\n\n 1. 减少延迟：由于连接已经建立，后续请求可以立即发送，而不会产生建立新 TCP 连接的开销。 这减少了请求-响应周期所花费的时间。\n 2. 连接重用：对多个请求重用同一个连接可以使服务器处理更多请求，而无需为每个请求建立新连接。\n    这对于具有许多单独获取的资源（例如图像、脚本、样式表）的网站尤其有利。\n 3. 连接限制：HTTP 服务器可以限制它们接受的并发连接数。 通过使用\n    Keep-Alive，客户端可以通过同一连接发出多个请求，而不会超出服务器的连接限制。\n\n要使用 Keep-Alive，客户端在 HTTP 请求中发送一个附加标头：\n\nConnection: keep-alive\n\n\n服务器可以使用相同的标头进行响应，以指示它支持此特定请求的持久连接。 如果标头不存在或设置为“关闭”（例如， Connection:\nclose)，这意味着服务器指示在发送当前响应后应关闭连接。\n\nHTTP/1.1 是 2021 年 9 月我的知识截止时的当前版本，它使持久连接成为默认行为，这意味着除非另有说明，否则隐式假定保持活动状态。\n\n需要注意的是，随着 HTTP/2 的引入，持久连接是默认的，并且不再需要“Connection: keep-alive”标头。 HTTP/2\n引入了多路复用，允许在单个连接上交错多个请求和响应，从而比以前的版本进一步提高了性能。\n\nHTTP Keep-Alive 仍然是 HTTP 协议发展过程中的一个重要历史概念，但它的显式使用在使用 HTTP/2 的现代 HTTP 实现中不太相关。\n\nQ：HTTP的请求报文 结构\n\nA：HTTP（Hypertext Transfer\nProtocol）的请求报文是客户端向服务器发送请求的格式。它包含了客户端希望执行的操作以及相应的资源信息。下面是HTTP请求报文的结构：\n\n 1. 请求行（Request Line）： 请求行包含了请求的方法（GET、POST、PUT、DELETE等），请求的目标URL以及HTTP协议版本。\n    \n    格式： <Method> <URL> <HTTP Version>\n    \n    示例： GET /example/page.html HTTP/1.1\n\n 2. 请求头部（Request Headers）：\n    请求头部包含了关于请求的附加信息，如用户代理信息、接受的内容类型等。每个头部字段都以名称和值的形式出现，中间用冒号分隔。\n    \n    示例：\n\nHost: www.example.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\nAccept-Language: en-US\n\n\n空行： 请求头部结束后是一个空行，用于分隔头部和请求体。\n\n请求体（Request Body）： 请求体可选，通常在POST请求中包含需要向服务器提交的数据。比如表单数据或JSON格式的数据。\n\n示例：\n\n 1. POST /example/form.php HTTP/1.1\n    Host: www.example.com\n    Content-Type: application/x-www-form-urlencoded\n    \n    username=johndoe&password=secretpassword\n    \n\n总结：HTTP请求报文是由请求行、请求头部、空行和请求体组成的，其中请求行指定请求方法、目标URL和HTTP版本，请求头部包含附加信息，空行用于分隔头部和请求体，请求体包含请求的数据（对于POST等请求）。\n\nQ：HTTP的响应报文结构\n\nA：HTTP（Hypertext Transfer\nProtocol）的响应报文是服务器向客户端返回的数据格式，用于响应客户端发起的HTTP请求。HTTP响应报文的结构由三个主要部分组成：状态行、消息报头（头部），以及响应正文。\n\n以下是HTTP响应报文的结构：\n\n 1. 状态行（Status Line）：\n    \n    * 格式：HTTP版本 状态码 状态码描述\n    * 示例：HTTP/1.1 200 OK\n    * 解释：\n      * HTTP版本：HTTP协议的版本号，如HTTP/1.1。\n      * 状态码：一个三位数字，用于表示请求处理的结果状态。常见的状态码有：\n        * 200 OK：请求成功。\n        * 404 Not Found：请求的资源未找到。\n        * 500 Internal Server Error：服务器端发生错误。\n        * 等等，详细的状态码信息可以在HTTP规范中找到。\n\n 2. 消息报头（Header）：\n    \n    * 格式：头字段名: 值\n    * 示例：Content-Type: text/html\n    * 解释：\n      * 头字段名：用于描述报文的各种属性，如Content-Type、Content-Length、Date等。\n      * 值：头字段对应的值，用于描述头字段的具体信息。\n    \n    HTTP报头包含了各种元信息，用于告知客户端有关响应的详细信息，例如：\n    \n    * Content-Type：指示响应正文的媒体类型（MIME类型），比如text/html、application/json等。\n    * Content-Length：指示响应正文的长度，以字节为单位。\n    * Server：指示服务器软件的名称和版本号。\n    * Date：指示服务器发送响应的日期和时间等。\n\n 3. 响应正文（Response Body）：\n    \n    * 格式：实际的响应数据，可以是HTML文档、JSON数据、图像文件等，根据Content-Type来解析内容类型。\n\n请注意，HTTP响应报文中的每个部分都以CRLF（回车换行）作为换行符，即/r/n。\n\n下面是一个完整的示例：\n\nphp\nHTTP/1.1 200 OK\nContent-Type: text/html\nContent-Length: 123\nDate: Wed， 26 Jul 2023 12:34:56 GMT\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Example</title>\n</head>\n<body>\n    <h1>Hello， World!</h1>\n</body>\n</html>\n\n\n在上面的例子中，状态行指示响应为HTTP/1.1版本，状态码为200（OK），状态码描述为\"OK\"。接下来是消息报头，指示了Content-Type为text/html，Content-Length为123字节，以及服务器发送响应的日期和时间。最后是响应正文，包含一个简单的HTML页面。\n\n这就是HTTP响应报文的基本结构，它允许服务器向客户端提供所请求的数据并提供一些元信息用于解释响应。","frontMatter":{"title":"网络协议withchatGPT","index":5,"publishTime":"2023/7/25"}}]},{"tableName":"说明文档","blogList":[{"name":"ReadMe","path":"说明文档/ReadMe.html","texts":"介绍\n\n这是个静态资源个人博客网站，也就是没有后端的网站。优点是不需要后端就可以创建，你可以把这个部署到github\npage上，缺点就是没有一般博客网站的功能，例如用户接口、互动之类的。这种网站一般用于纯粹存放文档，也就是个人博客。\n\n\n使用\n\n1.content文件夹就是存放你编写的博客的地方。具体存放文档详细的使用在请看项目网站。\n\n2.然后输入如下命令(需要确保你安装了node.js)\n\nnpm install\nnpm run build\nnpm run preview\n\n\n\n部署\n\n你可以查阅这个网站了解如何部署https://cn.vitejs.dev/guide/static-deploy.html\n\n如果你是部署到github page上，只要clone这个项目然后修改vite.config.js文件的baseURL就可以。","frontMatter":{"title":"必读","publishTime":"2023/7/23","index":1,"tags":["说明"]}},{"name":"FileStorage","path":"说明文档/FileStorage.html","texts":"结构\n\ncontetn文件夹内部结构应该是这样的：\n\ncontent\n -assets\n   -image1.webp\n -table1\n   -assets\n     -image2.webp\n   -blog1.md\n   -blog2.md\n -table2\n   -blog3.md\n   -image3.webp\n\n\n具体规则是：\n\n1.content文件夹内部创建的文件夹将视作一个博客列表\n\n2.博客列表内部存放.md文件，禁止递归创建列表\n\n3.图片文件可以存放在content文件夹内部的任意位置，但是要确保图片的引用路径为绝对路径（D:/Workspace/myblog/content/main/assets/image1.webp）\n\n4.如果你使用typora，你可以在偏好设置-》图像-》插入图片时选择复制图片到./assets文件夹","frontMatter":{"title":"文件存储","publishTime":"2023/7/23","index":2,"tags":["说明"]}},{"name":"IMGTest","path":"说明文档/IMGTest.html","texts":"","frontMatter":{"title":"图片测试","publishTime":"2023/7/23","index":3,"tags":["说明"]}},{"name":"SetFrontMatter","path":"说明文档/SetFrontMatter.html","texts":"说明\n\n你已经注意到了一个文档的展现包括作者，标题，发布时间，tags以及内容，你可以通过在.md文件的开头编写Yaml-Front-Matter来编辑这些属性。\n\n\n格式\n\n例如这一篇文章的Yaml-Front-Matter:\n\ntitle: 文章属性标注\npublishTime: 2023/7/23\nindex: 4\ntags: \n  - 说明\n\n\n解释：\n\ntitle：文章的标题，如果没有设置则使用文件的名字作为标题\n\npublishTime: 发布时间（内部类型是字符串，你可以随便写个字符串作为时间），如果没有则显示“未知”\n\nindex：严格的数字，表示文章在列表的顺序是第几位（如果index不存在则按照文件名字排序）\n\ntags：字符串数组，在文章表示为标签，如果没有就不会显示","frontMatter":{"title":"文章属性标注","publishTime":"2023/7/23","index":4,"tags":["说明"]}},{"name":"Issues","path":"说明文档/Issues.html","texts":"功能：\n\n1.右边会展示副标题列表，点击滚动条跳转到对应位置\n\n2.更好的博客列表展示\n\n3.搜索（可以不管）\n\n问题：\n\n1.目前不能规定顺序对博客列表进行排序，默认按照名字排，因为没有什么文件规定博客列表的属性，这可能会产生一些困扰。\n\n2.如果你在content目录下创建任何文件夹，即使内部没有.md文件，系统还是会认为是一个博客列表\n\n3.卡顿问题","frontMatter":{"title":"功能的不足以及bug","publishTime":"2023/7/23","index":5,"tags":["说明"]}},{"name":"UseSuggest","path":"说明文档/UseSuggest.html","texts":"这里给出一些建议： 1.将图片转换成900kb以内的webp文件来缩减大小减少网络压力。","frontMatter":{"title":"使用建议","publishTime":"2023/7/23","index":6,"tags":["说明"]}}]}]